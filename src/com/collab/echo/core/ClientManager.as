/* * Echo project. * * Copyright (C) 2003-2010 Collab * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program.  If not, see <http://www.gnu.org/licenses/>. */package com.collab.echo.core{    import com.collab.echo.core.messages.ChatMessageCreator;    import com.collab.echo.core.messages.chat.ChatMessage;    import com.collab.echo.core.rooms.BaseRoom;    import com.collab.echo.events.BaseConnectionEvent;    import com.collab.echo.events.BaseRoomEvent;    import com.collab.echo.model.UserVO;    import com.collab.echo.util.RoomUtils;    import com.collab.echo.util.StringUtil;        import net.user1.reactor.Reactor;    import net.user1.reactor.ReactorEvent;    import net.user1.reactor.RoomManagerEvent;    import net.user1.reactor.XMLSocketConnection;    /**     * <p>Manages the connection with the server, rooms and clients.</p>     *     * @author Thijs Triemstra     *      * @langversion 3.0 	 * @playerversion Flash 10     */    public class ClientManager implements IClientManager    {        // ====================================		// PRIVATE VARS		// ====================================        private var _connected      				: Boolean;        private var _clients      					: Array;		private var _hostUrl						: String;		private var _hostPort						: int;		private var _logLevel						: String;		private var _logging						: Boolean;		private var _rooms							: Vector.<BaseRoom>;		private var _conEvt							: BaseConnectionEvent;		private var _self							: *;				// XXX: might need to go elsewhere		private var _chatManager					: ChatMessageCreator;				// ====================================		// PROTECTED VARS		// ====================================		        // XXX: move to union subclass        protected var reactor						: Reactor;		// ====================================		// ACCESSOR/MUTATOR		// ====================================				public function get self():*		{			return reactor.self();		}				/**		 * Get rooms we want to monitor.		 * 		 * @return 		 */				public function get rooms():Vector.<BaseRoom>		{			return _rooms;		}		        /**         * Connection status.         *          * <p>True if the connection to the presence server has been successfully		 * completed.</p>		 *          * @return          */		        public function get connected():Boolean        {            return _connected;        }                /**		 * Clients we're monitoring.		 * 		 * @return 		 */				public function get clients():Array		{			return _clients;		}	        /**         * Constructor.         *           * @param url         * @param port         * @param logging         * @param logLevel         */		        public function ClientManager( url:String="localhost", port:int=9110,        							   logging:Boolean=true, logLevel:String="info" ) : void        {            _hostPort = port;			_hostUrl = url;			_logging = logging;            _connected = false;            _clients = [];			_logLevel = logLevel;			_chatManager = new ChatMessageCreator();			            connect();        }        /**         * Add a client.         *          * @param client         */		        public function subscribeClient( client : IClient ) : void        {            _clients.push( client );        }        /**         * Remove a client.         *           * @param client         */		        public function unsubscribeClient( client : IClient ) : void        {            for ( var ob:int = 0; ob < _clients.length; ob++ )            {                if ( _clients[ ob ] == client )                {                    _clients.splice( ob, 1 );                }            }        }        /**         * Notify all clients.         *           * @param notification         */		        public function notifyClient( notification:String, ...args:Array ) : void        {            for ( var notify:* in _clients )            {                _clients[ notify ].update( notification, args );            }        }                /**         * Registers a method or function to be executed when the specified type of message         * is received from the server.          *          * <p>This method can be used to register listeners that handle messages centrally         * for a group of rooms.</p>         *          * @example For example, suppose a multi-room chat application         * displays a notification icon when a new message is received in any room.         * To catch all incoming messages for all rooms, the application registers a         * single, centralized method for all "CHAT" messages. Here's the registration code:		 * 		 * <listing version="3.0">		 * msgManager.addServerMessageListener(Messages.CHAT, centralChatListener);</listing>         *          * @param type 		The name of the message the listener is registering to receive.         * @param method 	The function or method that will be invoked when the specified message         *                  is received.         * @param forRoomIDs  A list of room IDs. If the message was sent to any of the         *                    rooms in the list, the listener is executed. Otherwise, the         *                    listener is not executed. Applies to messages sent to rooms         *                    only, not to messages sent to specific individual clients or         *                    the entire server.         * @return 			  A Boolean indicating whether the listener was successfully added.         */                public function addServerMessageListener( type:String, method:Function, forRoomIDs:Array=null ):Boolean        {        	var result:Boolean = false;        	        	if ( type )        	{        		if ( !reactor.getMessageManager().hasMessageListener( type, method ))        		{        			if ( forRoomIDs == null )        			{        				// monitor all rooms        				forRoomIDs = RoomUtils.getRoomIDs( _rooms );        			}					result = reactor.getMessageManager().addMessageListener( type, method, forRoomIDs );        		}        	}        	        	if ( result )        	{        		//trace("addServerMessageListener - type: " + type + ", method: " + method );        	}        	        	return result;        }                /**         * Unregisters a message listener method that was earlier registered for message         * notifications via addServerMessageListener().         *          * @param type 		The string ID of the message for which the listener is unregistering.         * @param method 	The function or method to unregister.         * @return 			A Boolean indicating whether the listener was successfully removed.         */                public function removeServerMessageListener( type:String, method:Function ):Boolean        {        	var result:Boolean = false;        	        	if ( type )        	{        		if ( reactor.getMessageManager().hasMessageListener( type, method ))        		{					result = reactor.getMessageManager().removeMessageListener( type, method );        		}        	}        	        	return result;        }        /**         * Sends a message to clients in the room(s) specified by <code>forRoomIDs</code>.         *          * <p>To send a message to clients in a single room only, use BaseRoom's sendMessage()         * method.</p>         *           * @param message		The name of the message to send.         * @param forRoomIDs	The room(s) to which to send the message.         */		        public function sendServerMessage( message:ChatMessage, forRoomIDs:Array=null ) : void        {        	if ( forRoomIDs == null )        	{        		forRoomIDs = RoomUtils.getRoomIDs( _rooms );        	}        	            // result			if ( message.local )			{				// perform only locally				message.local = true;				message.sender = reactor.self();				// XXX: type needs to be dynamic				notifyClient( BaseRoomEvent.RECEIVE_MESSAGE, message );			}			else			{				// send remotely				reactor.getRoomManager().sendMessage( message.type, forRoomIDs,										 message.includeSelf, null, message.message );			}        }                /**         * Sends a message to clients in the room specified by <code>forRoomID</code>.         *          * @param type         * @param message		The name of the message to send.         * @param forRoomID		The room to which to send the message.         */		        public function sendRoomMessage( type:String, message:String, forRoomID:String ) : void        {        	var msg:*;        	        	switch ( type )        	{        		case BaseRoomEvent.SEND_MESSAGE:        			// XXX: remove the presence reference        			msg = _chatManager.create( 'presence', type, message, true );        			break;        		        		case BaseRoomEvent.SEND_LINE:        			msg = message;					break;        	}						trace('sendRoomMessage: ' + msg);												               sendServerMessage( msg, [ forRoomID ]);        }                /**         * Receieved a message.         *          * @param type		The name of the message to send.         * @param message	The text we received.         * @param from		User the message came from.         */	        public function receiveRoomMessage( type:String, message:String, from:* ) : void        {        	var msg:*;        	switch ( type )        	{        		case BaseRoomEvent.RECEIVE_MESSAGE:        			// XXX: remove the presence reference        			msg = _chatManager.create( 'presence', type, message );        			msg.sender = from;					msg.receiver = reactor.self();        			break;        		        		case BaseRoomEvent.RECEIVE_LINE:        			// XXX: formalize this					msg = new Object();					msg.shape = message;					msg.from = from;					break;        	}        	        	if ( msg )        	{				notifyClient( type, msg );        	}        }                /**		 * Disconnect from server. 		 */				public function closeConnection():void		{			notifyClient( BaseConnectionEvent.DISCONNECTING );		}		/**		 * Create one or more rooms.		 * 		 * @param rooms		 */				public function addRooms( rooms:Vector.<BaseRoom> ):void		{			_rooms = rooms;						if ( _connected )			{				createRooms();			}		}				/**		 * @param name		 * @return 		 */				public function getIPByUserName( name:String ):String		{			var ip:String;			var client:net.user1.reactor.IClient;			var id:String = name.substr( 4 );						if ( id )			{				// XXX: remove hardcoded name length				var poss:Array = [ getClientByAttribute( UserVO.USERNAME, name ),								   getClientById( id ) ];								for each ( client in poss )				{					if ( client )					{						// UNION BUG: this only works for own client						ip = client.getIP();						break;					}				}			}						return ip;		}				/**		 * Get user's client by attribute.		 * 		 * @param attrName		 * @param attrValue		 * @return 		 */				public function getClientByAttribute( attrName:String,													   attrValue:String ):*		{			return reactor.getClientManager().getClientByAttribute( attrName, attrValue );		}				/**		 * @param id		 * @return 		 */				public function getClientById( id:String ):*		{			return reactor.getClientManager().getClient( id );		}				// ====================================		// PROTECTED METHODS		// ====================================				/**		 * Create rooms.		 */				protected function createRooms():void		{			var room:BaseRoom;			for each ( room in _rooms )			{				// listen for room events				room.addEventListener( BaseRoomEvent.ADD_OCCUPANT, addOccupant );				room.addEventListener( BaseRoomEvent.REMOVE_OCCUPANT, removeOccupant );				room.addEventListener( BaseRoomEvent.OCCUPANT_COUNT, numClients );				room.addEventListener( BaseRoomEvent.JOIN_RESULT, joinedRoom );				room.addEventListener( BaseRoomEvent.ATTRIBUTE_UPDATE, attributeUpdate );								// create room				room.create( reactor );			}						watchRooms();		}				/**		 * Watch for rooms.		 */				protected function watchRooms():void		{			// watch for rooms			var ids:Vector.<BaseRoom> = new Vector.<BaseRoom>();			for each ( var room:BaseRoom in _rooms )			{				if ( room.watch )				{					ids.push( room );				}			}						var commonRoomQualifier:String = StringUtil.replace( "%s.*",												RoomUtils.getRoomsQualifiers( ids ));						reactor.getRoomManager().watchForRooms( commonRoomQualifier );		}				/**         * Connect to server.         */		        protected function connect():void        {            if ( _hostUrl && _hostPort )            {            	// notify others				notifyClient( BaseConnectionEvent.CONNECTING );			                trace( "Connecting to Union server on " + _hostUrl + ":" + _hostPort );                // create reactor                reactor = new Reactor( "", _logging );                                // logging                if ( _logLevel )                {                	reactor.getLog().setLevel( _logLevel );                }                                // reactor listeners                reactor.addEventListener( ReactorEvent.READY, unionConnectionReady );                reactor.addEventListener( ReactorEvent.CLOSE, unionConnectionClose );                                // XXX: xml connection                reactor.getConnectionManager().addConnection( new XMLSocketConnection( _hostUrl, _hostPort ));                                // connect                _connected = false;                reactor.connect();            }        }        		/**		 * Triggered when the connection is established and ready for use.		 */		protected function connectionReady():void		{			_connected = true;			notifyClient( BaseConnectionEvent.CONNECTION_SUCCESS );						createRooms();		}		/**		 * Triggered when the connection is closed.		 */		protected function connectionClosed():void		{            _connected = false;			notifyClient( BaseConnectionEvent.CONNECTION_CLOSED );		}		        // ====================================		// EVENT HANDLERS		// ====================================        /**		 * Triggered when the connection is established and ready for use.		 *		 * @param event		 */		protected function unionConnectionReady( event:ReactorEvent ):void		{            if ( event )            {			    event.preventDefault();            }                        // listen for room manager events			reactor.getRoomManager().addEventListener( RoomManagerEvent.ROOM_ADDED, 	roomAddedListener );			reactor.getRoomManager().addEventListener( RoomManagerEvent.ROOM_REMOVED, 	roomRemovedListener );			reactor.getRoomManager().addEventListener( RoomManagerEvent.ROOM_COUNT, 	roomCountListener );			connectionReady();		}		/**		 * Triggered when the connection is closed.		 *		 * @param event		 */		protected function unionConnectionClose( event:ReactorEvent ):void		{			if ( event )			{				event.preventDefault();			}						connectionClosed();		}				/**		 * Event listener triggered when a room is added to the          * room manager's room list.		 *	 		 * @param event		 */				protected function roomAddedListener( event:RoomManagerEvent ):void		{			event.preventDefault();						_conEvt = new BaseConnectionEvent( BaseConnectionEvent.ROOM_ADDED, event );			notifyClient( _conEvt.type, _conEvt );		}				/**		 * Event listener triggered when a room is removed from the          * room manager's room list.		 * 		 * @param event		 */				protected function roomRemovedListener( event:RoomManagerEvent ):void		{			event.preventDefault();						_conEvt = new BaseConnectionEvent( BaseConnectionEvent.ROOM_REMOVED, event );			notifyClient( _conEvt.type, _conEvt );						// XXX: cleanup corresponding baseroom instance		}				/**		 * Event listener triggered when the number of rooms has changed.		 * 		 * @param event		 */				protected function roomCountListener( event:RoomManagerEvent ):void		{			event.preventDefault();						_conEvt = new BaseConnectionEvent( BaseConnectionEvent.ROOM_COUNT, event );			notifyClient( _conEvt.type, _conEvt );		}		/**		 * Dispatched when the number of occupants in a room changes while the		 * current client is in, or observing, the room.		 *		 * @param event		 */		protected function numClients( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event.data.getNumClients() );		}		/**		 * Add a new occupant to the room.		 *		 * @param event		 */		protected function addOccupant( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}		/**		 * Remove occupant from the room.		 *		 * @param event		 */		protected function removeOccupant( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}		/**		 * Joined room.		 *		 * @param event		 */		protected function joinedRoom( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}		/**		 * Triggered when one of the room's attributes changes.		 *		 * @param event		 */		protected function attributeUpdate( event:BaseRoomEvent ):void		{			event.preventDefault();			notifyClient( event.type, event );		}		    }}