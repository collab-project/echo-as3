/* * Echo project. * * Copyright (C) 2003-2010 Collab * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program.  If not, see <http://www.gnu.org/licenses/>. */package com.collab.echo.core{    import com.collab.echo.core.messages.ChatMessageCreator;    import com.collab.echo.core.rooms.BaseRoom;    import com.collab.echo.events.BaseConnectionEvent;    import com.collab.echo.events.BaseRoomEvent;    import com.collab.echo.net.Connection;    import com.collab.echo.net.UnionConnection;        import net.user1.reactor.RoomManagerEvent;    /**     * <p>Manages the connection with the server, rooms and clients.</p>     *     * @author Thijs Triemstra     *      * @langversion 3.0 	 * @playerversion Flash 10     */    public class ClientManager implements IClientManager    {        // ====================================		// PRIVATE VARS		// ====================================        private var _clients      					: Array;		private var _rooms							: Vector.<BaseRoom>;		private var _connection						: Connection;				// XXX: might need to go elsewhere		private var _chatManager					: ChatMessageCreator;				// ====================================		// ACCESSOR/MUTATOR		// ====================================				/**		 * Get rooms we want to monitor.		 * 		 * @return 		 */				public function get rooms():Vector.<BaseRoom>		{			return _rooms;		}		        /**		 * Clients we're monitoring.		 * 		 * @return 		 */				public function get clients():Array		{			return _clients;		}	        /**         * Constructor.         *           * @param url         * @param port         * @param logging         * @param logLevel         */		        public function ClientManager( url:String="localhost", port:int=9110,        							   logging:Boolean=true, logLevel:String="info" ) : void        {            _clients = [];			_chatManager = new ChatMessageCreator();			_connection = new UnionConnection( url, port, logging, logLevel );                        connect();        }                /**         * Connect to server.         */		        public function connect():void        {        	// notify others			notifyClient( BaseConnectionEvent.CONNECTING );		            // listeners            /*            _connection.addEventListener( ReactorEvent.READY, unionConnectionReady );            _connection.addEventListener( ReactorEvent.CLOSE, unionConnectionClose );            */                        // connect            _connection.connect();        }        /**         * Add a client.         *          * @param client         */		        public function subscribeClient( client : IClient ) : void        {            _clients.push( client );        }        /**         * Remove a client.         *           * @param client         */		        public function unsubscribeClient( client : IClient ) : void        {            for ( var ob:int = 0; ob < _clients.length; ob++ )            {                if ( _clients[ ob ] == client )                {                    _clients.splice( ob, 1 );                }            }        }        /**         * Notify all clients.         *           * @param notification         */		        public function notifyClient( notification:String, ...args:Array ) : void        {            for ( var notify:* in _clients )            {                _clients[ notify ].update( notification, args );            }        }                /**		 * Create one or more rooms.		 * 		 * @param rooms		 */				public function addRooms( rooms:Vector.<BaseRoom> ):void		{			_rooms = rooms;						if ( _connection.connected )			{				createRooms();			}		}                /**         * Receieved a message.         *          * @param type		The name of the message to send.         * @param message	The text we received.         * @param from		User the message came from.         */	        public function receiveRoomMessage( type:String, message:String, from:* ) : void        {        	var msg:*;        	switch ( type )        	{        		case BaseRoomEvent.RECEIVE_MESSAGE:        			// XXX: remove the presence reference        			msg = _chatManager.create( type, message );        			msg.sender = from;					msg.receiver = _connection.self;        			break;        		        		case BaseRoomEvent.RECEIVE_LINE:        			// XXX: formalize this					msg = new Object();					msg.shape = message;					msg.from = from;					break;        	}        	        	if ( msg )        	{				notifyClient( type, msg );        	}        }                /**		 * Disconnect from server. 		 */				public function closeConnection():void		{			notifyClient( BaseConnectionEvent.DISCONNECTING );		}		// ====================================		// PROTECTED METHODS		// ====================================				/**		 * Create rooms.		 */				protected function createRooms():void		{			var room:BaseRoom;			for each ( room in _rooms )			{				// listen for room events				room.addEventListener( BaseRoomEvent.ADD_OCCUPANT, addOccupant );				room.addEventListener( BaseRoomEvent.REMOVE_OCCUPANT, removeOccupant );				room.addEventListener( BaseRoomEvent.OCCUPANT_COUNT, numClients );				room.addEventListener( BaseRoomEvent.JOIN_RESULT, joinedRoom );				room.addEventListener( BaseRoomEvent.ATTRIBUTE_UPDATE, attributeUpdate );								// create room				room.create( _connection );			}						_connection.watchRooms();		}				/**		 * Triggered when the connection is established and ready for use.		 */		protected function connectionReady():void		{			notifyClient( BaseConnectionEvent.CONNECTION_SUCCESS );						createRooms();		}		/**		 * Triggered when the connection is closed.		 */		protected function connectionClosed():void		{			notifyClient( BaseConnectionEvent.CONNECTION_CLOSED );		}		        // ====================================		// EVENT HANDLERS		// ====================================		/**		 * Dispatched when the number of occupants in a room changes while the		 * current client is in, or observing, the room.		 *		 * @param event		 */		protected function numClients( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event.data.getNumClients() );		}		/**		 * Add a new occupant to the room.		 *		 * @param event		 */		protected function addOccupant( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}		/**		 * Remove occupant from the room.		 *		 * @param event		 */		protected function removeOccupant( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}		/**		 * Joined room.		 *		 * @param event		 */		protected function joinedRoom( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}		/**		 * Triggered when one of the room's attributes changes.		 *		 * @param event		 */		protected function attributeUpdate( event:BaseRoomEvent ):void		{			event.preventDefault();			notifyClient( event.type, event );		}		    }}