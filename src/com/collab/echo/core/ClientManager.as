/*Echo project.Copyright (C) 2003-2011 CollabThis program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program.  If not, see <http://www.gnu.org/licenses/>.*/package com.collab.echo.core{	import com.collab.echo.core.rooms.BaseRoom;	import com.collab.echo.core.rooms.IRoom;	import com.collab.echo.errors.UnknownConnectionError;	import com.collab.echo.events.BaseConnectionEvent;	import com.collab.echo.events.BaseRoomEvent;	import com.collab.echo.model.UserVO;	import com.collab.echo.net.Connection;
		/**	 * Manages the connection with the server, rooms and clients.	 *	 * @author Thijs Triemstra	 * @langversion 3.0	 * @playerversion Flash 10	 * 	 * @example The following code demonstrates how to use class:	 * 	 * <listing version="3.0">	 * import com.collab.echo.net.Connection	 * 	 * var logging:Boolean = true;	 * var logLevel:String = "debug";	 * var man:ClientManager = new ClientManager(Connection, "localhost", 8000, logging, logLevel);	 * man.connect();</listing>	 */	public class ClientManager implements IClientManager	{		// ====================================		// PRIVATE VARS		// ====================================				private var _clients      		: Array;		private var _rooms				: Vector.<BaseRoom>;		private var _connection			: Connection;				// ====================================		// ACCESSOR/MUTATOR		// ====================================				/**		 * Room's we're monitoring.		 * 		 * @return		 * @see #createRooms()		 * @see #removeRooms()		 */				public function get rooms():Vector.<BaseRoom>		{			return _rooms;		}				/**		 * Clients we're monitoring.		 * 		 * @return 		 * @see #subscribeClient()		 * @see #unsubscribeClient()		 */				public function get clients():Array		{			return _clients;		}				/**		 * Manges connection with server, client and rooms.		 * 		 * @param connectionType	Connection subclass.		 * @param url				Connection URL.		 * @param port				Server port, eg. '9110'.		 * @param logging			Enable logging.		 * @param logLevel			Log level.		 * 		 * @see com.collab.echo.net.Connection Connection		 */				public function ClientManager( connectionType:Class, url:String="localhost",									   port:int=9110, logging:Boolean=true,									   logLevel:String="info" ) : void		{			_clients = [];			_rooms = new Vector.<BaseRoom>();						try			{				// establish new connection				_connection = new connectionType( url, port, logging, logLevel );			}			catch ( e:Error )			{				throw new UnknownConnectionError( connectionType );			}		}				/**		 * Connect to server.		 * 		 * This sets up listeners for the internal Connection and		 * makes the actual connect() call.		 * 		 * @see #disconnect()		 * @see com.collab.echo.net.Connection#connect()		 */				public function connect():void		{			// listeners			_connection.addEventListener( BaseConnectionEvent.CONNECTING,				connecting );			_connection.addEventListener( BaseConnectionEvent.CONNECTION_SUCCESS,				connectionReady );			_connection.addEventListener( BaseConnectionEvent.CONNECTION_CLOSED,				connectionClosed );			// connect			_connection.connect();		}				/**		 * Disconnect from server.		 * 		 * This removes the listeners for the internal Connection and		 * makes the actual disconnect() call.		 * 		 * @see #connect()		 * @see com.collab.echo.net.Connection#disconnect()		 */				public function disconnect():void		{			// TODO: cleanup listeners						// disconnect			_connection.disconnect();		}				/**		 * Add a client.		 * 		 * @param client		 * @see #unsubscribeClient()		 * @see #clients		 */				public function subscribeClient( client : IClient ) : void		{			_clients.push( client );		}				/**		 * Remove a client.		 *  		 * @param client		 * @see #subscribeClient()		 * @see #clients		 */				public function unsubscribeClient( client : IClient ) : void		{			var ob:int = 0;						for ( ob; ob < _clients.length; ob++ )			{				if ( _clients[ ob ] == client )				{					_clients.splice( ob, 1 );				}			}		}				/**		 * Create one or more rooms.		 * 		 * This adds BaseRoomEvent listeners for each room found in the		 * supplied <code>rooms</code> Vector and stores it in the		 * <code>rooms</code>. If the internal connection was ready and		 * connected prior to the call to this method, then the rooms will		 * be passed to the Connection's createRoom() method.		 * 		 * @param rooms	A Vector supplying BaseRoom instances.		 * @return 		Boolean indicating the rooms were valid.		 * @see #rooms		 * @see #removeRooms()		 * @see com.collab.echo.net.Connection#createRooms()		 */				public function createRooms( rooms:Vector.<BaseRoom> ):Boolean		{			var room:BaseRoom;			var result:Boolean = false;						if ( rooms && rooms.length > 0 )			{				// XXX: check if we're not adding duplicate rooms?				_rooms = _rooms.concat( rooms );								for each ( room in rooms )				{					// listen for events					room.addEventListener( BaseRoomEvent.ADD_OCCUPANT, addOccupant,						false, 0, true );					room.addEventListener( BaseRoomEvent.JOIN_RESULT, joinedRoom,						false, 0, true );					room.addEventListener( BaseRoomEvent.REMOVE_OCCUPANT,						removeOccupant, false, 0, true );					room.addEventListener( BaseRoomEvent.CLIENT_ATTRIBUTE_UPDATE,						clientAttributeUpdate, false, 0, true );					room.addEventListener( BaseRoomEvent.OCCUPANT_COUNT, numClients,						false, 0, true );				}								result = true;			}						// if an existing connection exists, create the rooms now,			// otherwise postpone but store the rooms			if ( result && _connection.connected )			{				_connection.createRooms( _rooms );			}						return result;		}				/**		 * Remove one or more rooms.		 * 		 * @param rooms		 * @return 		 * @see #createRooms()		 * @see #removeAllRooms()		 */				public function removeRooms( rooms:Vector.<BaseRoom> ):Boolean		{			// TODO			return false;		}				/**		 * Remove all rooms.		 * 		 * @return 		 * @see #removeRooms() 		 */				public function removeAllRooms():Boolean		{			var result:Boolean = false;						// TODO						return result;		}				/**		 * Notify all clients.		 *  		 * @param notification		 */				public function notifyClient( notification:String, ...args:Array ) : void		{			var client:*;			var vo:UserVO;						for ( client in _clients )			{				client = _clients[ client ];								if ( client is IRoom )				{					// IRoom implementations					switch ( notification )					{						case BaseRoomEvent.ADD_OCCUPANT:							vo = _connection.parseUser( args[0].data.getClient() );							client.addOccupant( vo );							break;												case BaseRoomEvent.REMOVE_OCCUPANT:							vo = _connection.parseUser( args[0].data.getClient() );							client.removeOccupant( vo );							break;												case BaseRoomEvent.OCCUPANT_COUNT:							client.numClients(  args[0] );							break;												case BaseRoomEvent.JOIN_RESULT:							break;												case BaseRoomEvent.CLIENT_ATTRIBUTE_UPDATE:							vo = _connection.parseUser( args[0].data.getClient() );							client.clientAttributeUpdate( vo, args[0].data.getChangedAttr() );							break;												default:							client.update( notification, args );							break;					}				}				else				{					// simple IClient implementations					client.update( notification, args );				}							}		}				// ====================================		// PROTECTED METHODS		// ====================================				/**		 * Triggered when the connection is created.		 *  		 * @param event		 */				protected function connecting( event:BaseConnectionEvent ):void		{			notifyClient( event.type );		}				/**		 * Triggered when the connection is established and ready for use.		 *  		 * @param event		 */				protected function connectionReady( event:BaseConnectionEvent ):void		{			notifyClient( event.type );						// create rooms			_connection.createRooms( _rooms );		}				/**		 * Triggered when the connection is closed.		 * 		 * @param event		 */		protected function connectionClosed( event:BaseConnectionEvent ):void		{			notifyClient( event.type );		}				// ====================================		// EVENT HANDLERS		// ====================================				/**		 * Dispatched when the number of occupants in a room changes while the		 * current client is in, or observing, the room.		 *		 * @param event		 */		protected function numClients( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event.data.getNumClients() );		}				/**		 * Add a new occupant to the room.		 *		 * @param event		 */		protected function addOccupant( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}				/**		 * Remove occupant from the room.		 *		 * @param event		 */		protected function removeOccupant( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}				/**		 * Joined room.		 *		 * @param event		 */		protected function joinedRoom( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}				/**		 * Triggered when one of the client's attributes changes.		 *		 * @param event		 */		protected function clientAttributeUpdate( event:BaseRoomEvent ):void		{			event.preventDefault();						notifyClient( event.type, event );		}			}}